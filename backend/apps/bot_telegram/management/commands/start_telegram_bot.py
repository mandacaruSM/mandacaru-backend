# ================================================================
# ARQUIVO: backend/apps/bot_telegram/management/commands/start_telegram_bot.py
# Comando atualizado com suporte completo a QR
# ================================================================

from django.core.management.base import BaseCommand
from django.conf import settings
import asyncio
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes
import logging
from datetime import datetime

# Importa√ß√µes dos modelos
from backend.apps.operadores.models import Operador
from backend.apps.equipamentos.models import Equipamento
from backend.apps.nr12_checklist.models import ChecklistNR12

# Importa√ß√µes do bot
from backend.apps.bot_telegram.handlers.message import text_handler
from backend.apps.bot_telegram.handlers.callback import callback_handler
from backend.apps.bot_telegram.handlers.qr import handle_qr_photo
from backend.apps.bot_telegram.utils.sessions import get_session, save_session, clear_session

logger = logging.getLogger(__name__)


class Command(BaseCommand):
    help = 'Inicia o Bot Telegram do Mandacaru ERP com suporte a QR Code'

    def add_arguments(self, parser):
        parser.add_argument(
            '--webhook',
            action='store_true',
            help='Usar webhook em vez de polling'
        )
        parser.add_argument(
            '--port',
            type=int,
            default=8443,
            help='Porta para o webhook (padr√£o: 8443)'
        )
        parser.add_argument(
            '--debug',
            action='store_true',
            help='Modo debug com logs detalhados'
        )

    def handle(self, *args, **options):
        
        
        self.stdout.write(self.style.SUCCESS('=' * 60))
        self.stdout.write(self.style.SUCCESS('ü§ñ INICIANDO BOT MANDACARU ERP'))
        self.stdout.write(self.style.SUCCESS('=' * 60))
        
        # Verificar configura√ß√µes
        if not self._verificar_configuracoes():
            return
        
        # Configurar logging
        if options['debug']:
            logging.basicConfig(level=logging.DEBUG)
        else:
            logging.basicConfig(level=logging.INFO)
        
        # Executar bot
        try:
            if options['webhook']:
                self._executar_webhook(options['port'])
            else:
                self._executar_polling()
        except KeyboardInterrupt:
            self.stdout.write(self.style.WARNING('\\n‚ö†Ô∏è Bot interrompido pelo usu√°rio'))
        except Exception as e:
            self.stdout.write(self.style.ERROR(f'‚ùå Erro ao executar bot: {e}'))
            raise

    def _verificar_configuracoes(self):
        
        
        self.stdout.write('üîç Verificando configura√ß√µes...')
        
        # Token do bot
        token = getattr(settings, 'TELEGRAM_BOT_TOKEN', None)
        if not token:
            self.stdout.write(self.style.ERROR('‚ùå TELEGRAM_BOT_TOKEN n√£o configurado!'))
            self.stdout.write('   Configure no arquivo .env')
            return False
        
        self.stdout.write(f'‚úÖ Token configurado: ...{token[-10:]}')
        
        # Verificar modelos
        try:
            total_operadores = Operador.objects.filter(status='ATIVO').count()
            total_equipamentos = Equipamento.objects.filter(ativo_nr12=True).count()
            
            self.stdout.write(f'‚úÖ Operadores ativos: {total_operadores}')
            self.stdout.write(f'‚úÖ Equipamentos NR12: {total_equipamentos}')
            
            if total_operadores == 0:
                self.stdout.write(self.style.WARNING('‚ö†Ô∏è Nenhum operador ativo encontrado'))
                self.stdout.write('   Execute: python manage.py criar_operadores_demo')
            
            if total_equipamentos == 0:
                self.stdout.write(self.style.WARNING('‚ö†Ô∏è Nenhum equipamento NR12 encontrado'))
                self.stdout.write('   Execute: python manage.py setup_nr12')
                
        except Exception as e:
            self.stdout.write(self.style.ERROR(f'‚ùå Erro ao verificar modelos: {e}'))
            return False
        
        # Verificar depend√™ncias
        try:
            import cv2
            import pyzbar
            self.stdout.write('‚úÖ Bibliotecas de QR Code instaladas')
        except ImportError as e:
            self.stdout.write(self.style.WARNING('‚ö†Ô∏è Bibliotecas de QR Code n√£o instaladas'))
            self.stdout.write('   Execute: pip install pyzbar opencv-python')
        
        return True

    def _executar_polling(self):
        
        
        self.stdout.write(self.style.SUCCESS('\\nüöÄ Iniciando bot em modo POLLING...'))
        
        # Criar aplica√ß√£o
        app = self._criar_aplicacao()
        
        # Informa√ß√µes
        self.stdout.write(self.style.SUCCESS('\\n‚úÖ Bot iniciado com sucesso!'))
        self.stdout.write('\\nüì± FUNCIONALIDADES DISPON√çVEIS:')
        self.stdout.write('   ‚Ä¢ Leitura de QR Code (fotos)')
        self.stdout.write('   ‚Ä¢ Login de operadores')
        self.stdout.write('   ‚Ä¢ Checklist NR12')
        self.stdout.write('   ‚Ä¢ Registro de abastecimentos')
        self.stdout.write('   ‚Ä¢ Reporte de anomalias')
        self.stdout.write('\\nüí° Pressione Ctrl+C para parar\\n')
        
        # Executar
        app.run_polling(allowed_updates=['message', 'callback_query'])

    def _executar_webhook(self, port):
    
        
        webhook_url = getattr(settings, 'TELEGRAM_WEBHOOK_URL', None)
        if not webhook_url:
            self.stdout.write(self.style.ERROR('‚ùå TELEGRAM_WEBHOOK_URL n√£o configurado!'))
            return
        
        self.stdout.write(self.style.SUCCESS(f'\\nüöÄ Iniciando bot em modo WEBHOOK...'))
        self.stdout.write(f'   URL: {webhook_url}')
        self.stdout.write(f'   Porta: {port}')
        
        # Criar aplica√ß√£o
        app = self._criar_aplicacao()
        
        # Executar
        app.run_webhook(
            listen="0.0.0.0",
            port=port,
            url_path=f"/{settings.TELEGRAM_BOT_TOKEN}",
            webhook_url=f"{webhook_url}/{settings.TELEGRAM_BOT_TOKEN}",
            allowed_updates=['message', 'callback_query']
        )

    def _criar_aplicacao(self):
        """Cria aplica√ß√£o do bot com handlers atualizados"""
        # Criar aplica√ß√£o
        app = Application.builder().token(settings.TELEGRAM_BOT_TOKEN).build()
        
        # Comandos principais
        app.add_handler(CommandHandler('start', self._cmd_start))
        app.add_handler(CommandHandler('help', self._cmd_help))
        app.add_handler(CommandHandler('status', self._cmd_status))
        app.add_handler(CommandHandler('logout', self._cmd_logout))
        app.add_handler(CommandHandler('admin', self._cmd_admin))
        
        # Handlers de conte√∫do com prioridade
        app.add_handler(MessageHandler(filters.PHOTO, handle_qr_photo), group=0)
        app.add_handler(text_handler, group=1)  # Usar o handler atualizado
        app.add_handler(callback_handler)       # Usar o handler atualizado
        
        # Error handler
        app.add_handler(self._error_handler)
        
        return app

    # ========================================
    # COMANDOS DO BOT
    # ========================================
    
    async def _cmd_start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):

        
        user_name = update.effective_user.first_name
        chat_id = str(update.effective_chat.id)
        session = get_session(chat_id)
        
        if session and session.get('autenticado'):
            # Usu√°rio j√° autenticado
            operador_nome = session.get('operador_nome', 'Operador')
            await update.message.reply_text(
                f"üëã Ol√° novamente, {operador_nome}!\\n\\n"
                f"üì∑ Escaneie o QR Code de um equipamento para continuar.\\n\\n"
                f"Ou use:\\n"
                f"/status - Ver seu status\\n"
                f"/logout - Sair do sistema\\n"
                f"/help - Ajuda"
            )
        else:
            # Novo usu√°rio
            await update.message.reply_text(
                f"üëã Bem-vindo ao Mandacaru ERP, {user_name}!\\n\\n"
                f"ü§ñ Sou o assistente virtual que vai ajud√°-lo com:\\n"
                f"‚Ä¢ Checklists NR12\\n"
                f"‚Ä¢ Registro de abastecimentos\\n"
                f"‚Ä¢ Reporte de anomalias\\n"
                f"‚Ä¢ Consulta de hist√≥ricos\\n\\n"
                f"üì∑ **Para come√ßar:**\\n"
                f"Envie uma foto do QR Code do seu cart√£o de operador.\\n\\n"
                f"üí° N√£o tem o QR Code? Entre em contato com seu supervisor."
            )

    async def _cmd_help(self, update: Update, context: ContextTypes.DEFAULT_TYPE):

        
        await update.message.reply_text(
            "üìö **AJUDA - Bot Mandacaru ERP**\\n\\n"
            "üîπ **Como usar:**\\n"
            "1. Escaneie o QR do seu cart√£o (login)\\n"
            "2. Escaneie o QR de um equipamento\\n"
            "3. Escolha a a√ß√£o desejada\\n\\n"
            "üîπ **Comandos dispon√≠veis:**\\n"
            "/start - Iniciar bot\\n"
            "/status - Ver seu status\\n"
            "/logout - Sair do sistema\\n"
            "/help - Esta mensagem\\n\\n"
            "üîπ **Dicas para QR Code:**\\n"
            "‚Ä¢ Boa ilumina√ß√£o\\n"
            "‚Ä¢ C√¢mera est√°vel\\n"
            "‚Ä¢ QR Code limpo\\n"
            "‚Ä¢ Dist√¢ncia adequada\\n\\n"
            "‚ùì Problemas? Contate seu supervisor."
        )

    async def _cmd_status(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
    
        
        chat_id = str(update.effective_chat.id)
        session = get_session(chat_id)
        
        if not session or not session.get('autenticado'):
            await update.message.reply_text(
                "‚ùå Voc√™ n√£o est√° autenticado.\\n\\n"
                "üì∑ Escaneie o QR Code do seu cart√£o para fazer login."
            )
            return
        
        # Buscar dados do operador
        try:
            from asgiref.sync import sync_to_async
            
            operador_id = session.get('operador_id')
            operador = await sync_to_async(Operador.objects.get)(id=operador_id)
            
            # Estat√≠sticas
            hoje = datetime.now().date()
            checklists_hoje = await sync_to_async(
                ChecklistNR12.objects.filter(
                    operador=operador,
                    data_checklist=hoje
                ).count
            )()
            
            await update.message.reply_text(
                f"üìä **SEU STATUS**\\n\\n"
                f"üë§ Nome: {operador.nome}\\n"
                f"üíº Fun√ß√£o: {operador.funcao}\\n"
                f"üè¢ Setor: {operador.setor}\\n"
                f"üìÖ Admiss√£o: {operador.data_admissao.strftime('%d/%m/%Y')}\\n\\n"
                f"üìà **Hoje:**\\n"
                f"‚úÖ Checklists realizados: {checklists_hoje}\\n\\n"
                f"üîê Sess√£o ativa desde: {session.get('ultimo_acesso', 'N/A')}"
            )
            
        except Exception as e:
            logger.error(f"Erro ao buscar status: {e}")
            await update.message.reply_text(
                "‚ùå Erro ao buscar seus dados.\\n"
                "Tente novamente mais tarde."
            )

    async def _cmd_logout(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
    
        
        chat_id = str(update.effective_chat.id)
        session = get_session(chat_id)
        
        if session and session.get('autenticado'):
            nome = session.get('operador_nome', 'Operador')
            clear_session(chat_id)
            
            await update.message.reply_text(
                f"üëã Logout realizado com sucesso!\\n\\n"
                f"At√© logo, {nome}!\\n\\n"
                f"Para usar novamente, escaneie seu QR Code."
            )
        else:
            await update.message.reply_text(
                "‚ùå Voc√™ n√£o est√° autenticado."
            )

    async def _cmd_admin(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
    
        
        user_id = str(update.effective_user.id)
        admin_ids = getattr(settings, 'ADMIN_IDS', [])
        
        if user_id not in admin_ids:
            await update.message.reply_text(
                "‚ùå Acesso negado.\\n"
                "Este comando √© apenas para administradores."
            )
            return
        
        # Menu administrativo
        keyboard = [
            [InlineKeyboardButton("üìä Estat√≠sticas", callback_data="admin_stats")],
            [InlineKeyboardButton("üë• Operadores Online", callback_data="admin_users")],
            [InlineKeyboardButton("üîÑ Limpar Cache", callback_data="admin_clear_cache")],
            [InlineKeyboardButton("üìã Logs Recentes", callback_data="admin_logs")],
            [InlineKeyboardButton("üîß Status Sistema", callback_data="admin_system")],
            [InlineKeyboardButton("‚ùå Fechar", callback_data="admin_close")]
        ]
        
        await update.message.reply_text(
            "üîß **PAINEL ADMINISTRATIVO**\\n\\n"
            "Selecione uma op√ß√£o:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    async def _error_handler(self, update: object, context: ContextTypes.DEFAULT_TYPE):
    
        
        logger.error(f"Erro no update {update}: {context.error}")
        
        # Tentar notificar o usu√°rio
        if update and hasattr(update, 'effective_message'):
            try:
                await update.effective_message.reply_text(
                    "‚ùå Ocorreu um erro ao processar sua solicita√ß√£o.\\n"
                    "Por favor, tente novamente.\\n\\n"
                    "Se o problema persistir, contate o suporte."
                )
            except Exception as e:
                logger.error(f"Erro ao enviar mensagem de erro: {e}")
        
        # Notificar admins em erros cr√≠ticos
        if isinstance(context.error, Exception):
            error_message = f"üö® ERRO NO BOT:\\n{type(context.error).__name__}: {str(context.error)}"
            admin_ids = getattr(settings, 'ADMIN_IDS', [])
            
            for admin_id in admin_ids:
                try:
                    await context.bot.send_message(
                        chat_id=admin_id,
                        text=error_message
                    )
                except:
                    pass

    # ========================================
    # CALLBACKS ADMINISTRATIVOS
    # ========================================
    
    async def _handle_admin_callback(self, query, data):
    
        
        from asgiref.sync import sync_to_async
        from backend.apps.bot_telegram.utils.sessions import _memory_sessions
        
        try:
            if data == "admin_stats":
                # Estat√≠sticas gerais
                total_operadores = await sync_to_async(Operador.objects.filter(status='ATIVO').count)()
                total_equipamentos = await sync_to_async(Equipamento.objects.filter(ativo_nr12=True).count)()
                
                hoje = datetime.now().date()
                checklists_hoje = await sync_to_async(
                    ChecklistNR12.objects.filter(data_checklist=hoje).count
                )()
                checklists_concluidos = await sync_to_async(
                    ChecklistNR12.objects.filter(
                        data_checklist=hoje,
                        status='CONCLUIDO'
                    ).count
                )()
                
                # Sess√µes ativas
                sessoes_ativas = len([s for s in _memory_sessions.values() 
                                    if s.get('autenticado')])
                
                await query.edit_message_text(
                    f"üìä **ESTAT√çSTICAS DO SISTEMA**\\n\\n"
                    f"üë• Operadores ativos: {total_operadores}\\n"
                    f"üîß Equipamentos NR12: {total_equipamentos}\\n\\n"
                    f"üìÖ **HOJE ({hoje.strftime('%d/%m/%Y')}):**\\n"
                    f"üìã Checklists criados: {checklists_hoje}\\n"
                    f"‚úÖ Checklists conclu√≠dos: {checklists_concluidos}\\n"
                    f"üì± Usu√°rios online: {sessoes_ativas}\\n\\n"
                    f"üïê Atualizado: {datetime.now().strftime('%H:%M:%S')}"
                )
                
            elif data == "admin_users":
                # Usu√°rios online
                usuarios_online = []
                for chat_id, session in _memory_sessions.items():
                    if session.get('autenticado'):
                        usuarios_online.append(
                            f"‚Ä¢ {session.get('operador_nome', 'N/A')} "
                            f"({session.get('operador_codigo', 'N/A')})"
                        )
                
                if usuarios_online:
                    lista = "\\n".join(usuarios_online[:20])  # Limitar a 20
                    texto = f"üë• **USU√ÅRIOS ONLINE ({len(usuarios_online)}):**\\n\\n{lista}"
                    if len(usuarios_online) > 20:
                        texto += f"\\n\\n... e mais {len(usuarios_online) - 20} usu√°rios"
                else:
                    texto = "üë• Nenhum usu√°rio online no momento."
                
                await query.edit_message_text(texto)
                
            elif data == "admin_clear_cache":
                # Limpar cache/sess√µes
                sessoes_limpas = len(_memory_sessions)
                _memory_sessions.clear()
                
                await query.edit_message_text(
                    f"üîÑ **CACHE LIMPO**\\n\\n"
                    f"‚úÖ {sessoes_limpas} sess√µes removidas\\n"
                    f"‚úÖ Mem√≥ria liberada\\n\\n"
                    f"‚ö†Ô∏è Todos os usu√°rios precisar√£o fazer login novamente."
                )
                
            elif data == "admin_logs":
                # Logs recentes (simulado)
                await query.edit_message_text(
                    "üìã **LOGS RECENTES**\\n\\n"
                    "Para logs completos, verifique:\\n"
                    "‚Ä¢ Arquivo: `logs/bot.log`\\n"
                    "‚Ä¢ Console do servidor\\n"
                    "‚Ä¢ Django Admin\\n\\n"
                    "Use: `tail -f logs/bot.log`"
                )
                
            elif data == "admin_system":
                # Status do sistema
                import psutil
                import platform
                
                # Informa√ß√µes do sistema
                cpu_percent = psutil.cpu_percent(interval=1)
                memory = psutil.virtual_memory()
                disk = psutil.disk_usage('/')
                
                # Uptime do bot (simulado)
                uptime = datetime.now() - datetime.now().replace(
                    hour=0, minute=0, second=0, microsecond=0
                )
                
                await query.edit_message_text(
                    f"üîß **STATUS DO SISTEMA**\\n\\n"
                    f"üñ•Ô∏è **Servidor:**\\n"
                    f"‚Ä¢ OS: {platform.system()} {platform.release()}\\n"
                    f"‚Ä¢ Python: {platform.python_version()}\\n"
                    f"‚Ä¢ Django: {settings.VERSION if hasattr(settings, 'VERSION') else 'N/A'}\\n\\n"
                    f"üìä **Recursos:**\\n"
                    f"‚Ä¢ CPU: {cpu_percent}%\\n"
                    f"‚Ä¢ RAM: {memory.percent}% ({memory.used // (1024**3)}GB/{memory.total // (1024**3)}GB)\\n"
                    f"‚Ä¢ Disco: {disk.percent}% usado\\n\\n"
                    f"‚è±Ô∏è **Uptime:** {str(uptime).split('.')[0]}"
                )
                
            elif data == "admin_close":
                await query.edit_message_text("‚úÖ Painel administrativo fechado.")
                
        except Exception as e:
            logger.error(f"Erro no callback admin: {e}")
            await query.edit_message_text(
                f"‚ùå Erro ao processar comando administrativo:\\n{str(e)}"
            )

    # ========================================
    # M√âTODOS AUXILIARES
    # ========================================
    
    def _formatar_tempo(self, segundos):
        
        horas = segundos // 3600
        minutos = (segundos % 3600) // 60
        segundos = segundos % 60
        
        if horas > 0:
            return f"{horas}h {minutos}m"
        elif minutos > 0:
            return f"{minutos}m {segundos}s"
        else:
            return f"{segundos}s"
    
    def _verificar_horario_trabalho(self):
    
        agora = datetime.now()
        hora = agora.hour
        dia_semana = agora.weekday()  # 0=Segunda, 6=Domingo
        
        # Segunda a Sexta, 6h √†s 22h
        if dia_semana < 5:  # Dias √∫teis
            return 6 <= hora < 22
        # S√°bado, 6h √†s 18h
        elif dia_semana == 5:
            return 6 <= hora < 18
        # Domingo - fechado
        else:
            return False


# ================================================================
# EXEMPLO DE USO E TESTES
# ================================================================



    
    import sys
    import os
    
    # Adicionar o diret√≥rio raiz ao path
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))))
    
    # Configurar Django
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')
    import django
    django.setup()
    
    # Executar comando
    from django.core.management import execute_from_command_line
    #execute_from_command_line(['manage.py', 'start_telegram_bot', '--debug'])

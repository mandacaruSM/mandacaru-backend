# ================================================================
# ARQUIVO: backend/apps/bot_telegram/handlers/qr.py
# Implementa√ß√£o do leitor de QR Code baseado no easy-qr-scan-bot
# ================================================================

import io
import logging
from typing import Optional, Dict, Any
from telegram import Update, PhotoSize
from telegram.ext import ContextTypes
from PIL import Image
import cv2
import numpy as np
from pyzbar import pyzbar
from pyzbar.pyzbar import ZBarSymbol
import json
import re
from asgiref.sync import sync_to_async
from django.conf import settings

# Importa√ß√µes dos modelos
from backend.apps.operadores.models import Operador
from backend.apps.equipamentos.models import Equipamento
from backend.apps.nr12_checklist.models import ChecklistNR12

logger = logging.getLogger(__name__)


class QRCodeReader:
    """Classe para leitura e processamento de QR Codes"""
    
    def __init__(self):
        self.max_file_size = 20 * 1024 * 1024  # 20MB
        self.supported_formats = ['JPEG', 'PNG', 'BMP', 'WEBP']
    
    async def process_photo(self, photo: PhotoSize) -> Optional[str]:
        """Processa uma foto do Telegram e extrai QR Code"""
        try:
            # Baixar arquivo
            photo_file = await photo.get_file()
            photo_bytes = await photo_file.download_as_bytearray()
            
            # Verificar tamanho
            if len(photo_bytes) > self.max_file_size:
                raise ValueError("Arquivo muito grande (m√°x 20MB)")
            
            # Converter para imagem
            image = Image.open(io.BytesIO(photo_bytes))
            
            # Tentar m√∫ltiplos m√©todos de detec√ß√£o
            qr_data = await self._detect_qr_multiple_methods(image)
            
            return qr_data
            
        except Exception as e:
            logger.error(f"Erro ao processar foto: {e}")
            return None
    
    async def _detect_qr_multiple_methods(self, image: Image) -> Optional[str]:
        """Tenta detectar QR Code usando m√∫ltiplos m√©todos"""
        
        # M√©todo 1: Detec√ß√£o direta
        qr_data = self._detect_qr_direct(image)
        if qr_data:
            return qr_data
        
        # M√©todo 2: Com pr√©-processamento
        qr_data = self._detect_qr_preprocessed(image)
        if qr_data:
            return qr_data
        
        # M√©todo 3: Com rota√ß√µes
        qr_data = self._detect_qr_rotated(image)
        if qr_data:
            return qr_data
        
        return None
    
    def _detect_qr_direct(self, image: Image) -> Optional[str]:
        """Detec√ß√£o direta de QR Code"""
        try:
            # Converter para array numpy
            img_array = np.array(image)
            
            # Detectar QR codes
            decoded_objects = pyzbar.decode(img_array, symbols=[ZBarSymbol.QRCODE])
            
            if decoded_objects:
                return decoded_objects[0].data.decode('utf-8')
        except Exception as e:
            logger.debug(f"Erro na detec√ß√£o direta: {e}")
        
        return None
    
    def _detect_qr_preprocessed(self, image: Image) -> Optional[str]:
        """Detec√ß√£o com pr√©-processamento da imagem"""
        try:
            # Converter para escala de cinza
            gray = cv2.cvtColor(np.array(image), cv2.COLOR_RGB2GRAY)
            
            # Aplicar threshold adaptativo
            thresh = cv2.adaptiveThreshold(
                gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
                cv2.THRESH_BINARY, 11, 2
            )
            
            # Detectar QR codes
            decoded_objects = pyzbar.decode(thresh, symbols=[ZBarSymbol.QRCODE])
            
            if decoded_objects:
                return decoded_objects[0].data.decode('utf-8')
        except Exception as e:
            logger.debug(f"Erro no pr√©-processamento: {e}")
        
        return None
    
    def _detect_qr_rotated(self, image: Image) -> Optional[str]:
        """Detec√ß√£o com rota√ß√µes da imagem"""
        try:
            for angle in [0, 90, 180, 270]:
                rotated = image.rotate(angle, expand=True)
                decoded_objects = pyzbar.decode(
                    np.array(rotated), 
                    symbols=[ZBarSymbol.QRCODE]
                )
                
                if decoded_objects:
                    return decoded_objects[0].data.decode('utf-8')
        except Exception as e:
            logger.debug(f"Erro na rota√ß√£o: {e}")
        
        return None


class QRCodeProcessor:
    """Processa dados extra√≠dos do QR Code"""
    
    def __init__(self):
        self.reader = QRCodeReader()
    
    async def process_qr_data(self, qr_data: str) -> Dict[str, Any]:
        """Processa e identifica o tipo de QR Code"""
        
        # Tentar JSON primeiro
        try:
            data = json.loads(qr_data)
            return await self._process_json_qr(data)
        except json.JSONDecodeError:
            pass
        
        # Processar como string
        return await self._process_string_qr(qr_data)
    
    async def _process_json_qr(self, data: dict) -> Dict[str, Any]:
        """Processa QR Code em formato JSON"""
        
        qr_type = data.get('tipo', data.get('type'))
        
        if qr_type == 'operador':
            return {
                'tipo': 'operador',
                'codigo': data.get('codigo'),
                'nome': data.get('nome'),
                'dados': data
            }
        elif qr_type == 'equipamento':
            return {
                'tipo': 'equipamento',
                'id': data.get('id'),
                'codigo': data.get('codigo'),
                'dados': data
            }
        elif qr_type == 'checklist':
            return {
                'tipo': 'checklist',
                'uuid': data.get('uuid'),
                'dados': data
            }
        else:
            return {
                'tipo': 'desconhecido',
                'dados': data
            }
    
    async def _process_string_qr(self, qr_data: str) -> Dict[str, Any]:
        """Processa QR Code em formato string"""
        
        # Padr√µes para identificar tipos
        patterns = {
            'operador': [
                r'^OP\d+$',  # OP0001
                r'^OPERADOR:\d+$',  # OPERADOR:123
                r'^O-\d+$',  # O-123
            ],
            'equipamento': [
                r'^EQ\d+$',  # EQ0001
                r'^E-\d+$',  # E-123
                r'^EQUIP:\d+$',  # EQUIP:123
                r'equipamento[/_-](\d+)',  # equipamento/123
            ],
            'checklist': [
                r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$',  # UUID
                r'^CL-\d+$',  # CL-123
            ],
            'url': [
                r'^https?://',  # URLs
                r'^t\.me/',  # Links do Telegram
            ]
        }
        
        # Verificar cada padr√£o
        for tipo, padroes in patterns.items():
            for padrao in padroes:
                if re.match(padrao, qr_data, re.IGNORECASE):
                    return {
                        'tipo': tipo,
                        'valor': qr_data,
                        'padrao': padrao
                    }
        
        # Se for URL do sistema
        if 'mandacaru' in qr_data.lower() or settings.BASE_URL in qr_data:
            return await self._process_system_url(qr_data)
        
        return {
            'tipo': 'texto',
            'valor': qr_data
        }
    
    async def _process_system_url(self, url: str) -> Dict[str, Any]:
        """Processa URLs do sistema Mandacaru"""
        
        # Extrair informa√ß√µes da URL
        patterns = {
            r'/equipamento/(\d+)': ('equipamento', 'id'),
            r'/operador/(\w+)': ('operador', 'codigo'),
            r'/checklist/([0-9a-f-]+)': ('checklist', 'uuid'),
            r'start=eq(\d+)': ('equipamento', 'id'),
            r'start=op(\w+)': ('operador', 'codigo'),
        }
        
        for pattern, (tipo, campo) in patterns.items():
            match = re.search(pattern, url, re.IGNORECASE)
            if match:
                return {
                    'tipo': tipo,
                    campo: match.group(1),
                    'url_original': url
                }
        
        return {
            'tipo': 'url',
            'valor': url
        }


# Handler principal para fotos
async def handle_qr_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler principal para processar fotos com QR Code"""
    
    chat_id = update.effective_chat.id
    user_id = update.effective_user.id
    
    # Mensagem de processamento
    processing_msg = await update.message.reply_text(
        "üîç Processando QR Code...",
        reply_to_message_id=update.message.message_id
    )
    
    try:
        # Obter a foto de maior resolu√ß√£o
        photo = update.message.photo[-1]
        
        # Processar QR Code
        processor = QRCodeProcessor()
        qr_data = await processor.reader.process_photo(photo)
        
        if not qr_data:
            await processing_msg.edit_text(
                "‚ùå N√£o foi poss√≠vel detectar um QR Code na imagem.\n\n"
                "üí° Dicas:\n"
                "‚Ä¢ Certifique-se que o QR Code est√° bem vis√≠vel\n"
                "‚Ä¢ Evite reflexos e sombras\n"
                "‚Ä¢ Mantenha a c√¢mera est√°vel\n"
                "‚Ä¢ Tente aproximar ou afastar a c√¢mera"
            )
            return
        
        # Processar dados do QR
        qr_info = await processor.process_qr_data(qr_data)
        
        # Processar conforme o tipo
        if qr_info['tipo'] == 'operador':
            await _process_operador_qr(update, context, qr_info, processing_msg)
        elif qr_info['tipo'] == 'equipamento':
            await _process_equipamento_qr(update, context, qr_info, processing_msg)
        elif qr_info['tipo'] == 'checklist':
            await _process_checklist_qr(update, context, qr_info, processing_msg)
        else:
            await processing_msg.edit_text(
                f"üìã QR Code detectado!\n\n"
                f"Tipo: {qr_info['tipo']}\n"
                f"Dados: `{qr_data[:100]}{'...' if len(qr_data) > 100 else ''}`\n\n"
                f"‚ö†Ô∏è Este tipo de QR Code ainda n√£o √© suportado."
            )
    
    except Exception as e:
        logger.error(f"Erro ao processar QR Code: {e}")
        await processing_msg.edit_text(
            "‚ùå Erro ao processar a imagem.\n"
            "Por favor, tente novamente."
        )


async def _process_operador_qr(update: Update, context: ContextTypes.DEFAULT_TYPE, 
                              qr_info: dict, processing_msg):
    """Processa QR Code de operador"""
    
    from backend.apps.bot_telegram.utils.sessions import save_session, get_session
    
    try:
        # Extrair c√≥digo do operador
        codigo = qr_info.get('codigo') or qr_info.get('valor', '').replace('OP', '')
        
        # Buscar operador no banco
        operador = await sync_to_async(Operador.objects.filter(
            codigo=codigo,
            status='ATIVO',
            ativo_bot=True
        ).first)()
        
        if not operador:
            await processing_msg.edit_text(
                "‚ùå Operador n√£o encontrado ou n√£o autorizado.\n\n"
                "Verifique se:\n"
                "‚Ä¢ O QR Code est√° correto\n"
                "‚Ä¢ Voc√™ est√° ativo no sistema\n"
                "‚Ä¢ Tem permiss√£o para usar o bot"
            )
            return
        
        # Salvar na sess√£o
        chat_id = str(update.effective_chat.id)
        save_session(chat_id, {
            'operador_id': operador.id,
            'operador_codigo': operador.codigo,
            'operador_nome': operador.nome,
            'operador_funcao': operador.funcao,
            'autenticado': True
        })
        
        # Atualizar √∫ltimo acesso
        await sync_to_async(operador.atualizar_ultimo_acesso)(chat_id)
        
        # Mensagem de sucesso
        await processing_msg.edit_text(
            f"‚úÖ **Login realizado com sucesso!**\n\n"
            f"üë§ Operador: {operador.nome}\n"
            f"üíº Fun√ß√£o: {operador.funcao}\n"
            f"üè¢ Setor: {operador.setor}\n\n"
            f"üì± **Agora voc√™ pode:**\n"
            f"‚Ä¢ Escanear QR de equipamentos\n"
            f"‚Ä¢ Realizar checklists NR12\n"
            f"‚Ä¢ Registrar abastecimentos\n"
            f"‚Ä¢ Reportar anomalias\n\n"
            f"üîß Escaneie o QR de um equipamento para come√ßar!"
        )
        
    except Exception as e:
        logger.error(f"Erro ao processar operador: {e}")
        await processing_msg.edit_text(
            "‚ùå Erro ao processar login do operador.\n"
            "Por favor, tente novamente."
        )


async def _process_equipamento_qr(update: Update, context: ContextTypes.DEFAULT_TYPE,
                                 qr_info: dict, processing_msg):
    """Processa QR Code de equipamento"""
    
    from backend.apps.bot_telegram.utils.sessions import get_session
    from telegram import InlineKeyboardButton, InlineKeyboardMarkup
    
    try:
        # Verificar se operador est√° logado
        chat_id = str(update.effective_chat.id)
        session = get_session(chat_id)
        
        if not session or not session.get('autenticado'):
            await processing_msg.edit_text(
                "‚ùå Voc√™ precisa fazer login primeiro!\n\n"
                "üì∑ Escaneie o QR Code do seu cart√£o de operador."
            )
            return
        
        # Extrair ID do equipamento
        equip_id = qr_info.get('id') or qr_info.get('valor', '').replace('EQ', '')
        
        # Buscar equipamento
        equipamento = await sync_to_async(Equipamento.objects.filter(
            id=equip_id,
            ativo_nr12=True
        ).first)()
        
        if not equipamento:
            await processing_msg.edit_text(
                "‚ùå Equipamento n√£o encontrado ou n√£o est√° ativo para NR12."
            )
            return
        
        # Verificar permiss√£o do operador
        operador_id = session.get('operador_id')
        operador = await sync_to_async(Operador.objects.get)(id=operador_id)
        
        pode_operar = await sync_to_async(operador.pode_operar_equipamento)(equipamento)
        
        if not pode_operar:
            await processing_msg.edit_text(
                f"‚ùå Voc√™ n√£o tem permiss√£o para operar:\n"
                f"üîß {equipamento.nome}\n\n"
                f"Entre em contato com seu supervisor."
            )
            return
        
        # Salvar equipamento na sess√£o
        session['equipamento_atual'] = {
            'id': equipamento.id,
            'nome': equipamento.nome,
            'codigo': equipamento.codigo
        }
        save_session(chat_id, session)
        
        # Criar menu de op√ß√µes
        keyboard = [
            [InlineKeyboardButton("üìã Checklist NR12", callback_data=f"checklist_{equipamento.id}")],
            [InlineKeyboardButton("‚õΩ Abastecimento", callback_data=f"abastecimento_{equipamento.id}")],
            [InlineKeyboardButton("‚ö†Ô∏è Reportar Anomalia", callback_data=f"anomalia_{equipamento.id}")],
            [InlineKeyboardButton("üìä Ver Hist√≥rico", callback_data=f"historico_{equipamento.id}")],
            [InlineKeyboardButton("‚ùå Cancelar", callback_data="cancelar")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Mensagem com informa√ß√µes do equipamento
        await processing_msg.edit_text(
            f"üîß **Equipamento Identificado**\n\n"
            f"üìå Nome: {equipamento.nome}\n"
            f"üè∑Ô∏è C√≥digo: {equipamento.codigo}\n"
            f"üè≠ Marca: {equipamento.marca}\n"
            f"üìê Modelo: {equipamento.modelo}\n"
            f"üè¢ Cliente: {equipamento.cliente.razao_social if equipamento.cliente else 'N/A'}\n\n"
            f"‚ùì **O que deseja fazer?**",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Erro ao processar equipamento: {e}")
        await processing_msg.edit_text(
            "‚ùå Erro ao processar equipamento.\n"
            "Por favor, tente novamente."
        )


async def _process_checklist_qr(update: Update, context: ContextTypes.DEFAULT_TYPE,
                               qr_info: dict, processing_msg):
    """Processa QR Code de checklist"""
    
    try:
        # Extrair UUID do checklist
        checklist_uuid = qr_info.get('uuid') or qr_info.get('valor')
        
        # Buscar checklist
        checklist = await sync_to_async(ChecklistNR12.objects.filter(
            uuid=checklist_uuid
        ).select_related('equipamento', 'operador').first)()
        
        if not checklist:
            await processing_msg.edit_text(
                "‚ùå Checklist n√£o encontrado."
            )
            return
        
        # Formatar status
        status_emoji = {
            'PENDENTE': '‚è≥',
            'EM_ANDAMENTO': 'üîÑ',
            'CONCLUIDO': '‚úÖ',
            'CANCELADO': '‚ùå'
        }
        
        # Informa√ß√µes do checklist
        await processing_msg.edit_text(
            f"üìã **Checklist NR12**\n\n"
            f"üîß Equipamento: {checklist.equipamento.nome}\n"
            f"üë§ Operador: {checklist.operador.nome}\n"
            f"üìÖ Data: {checklist.data_checklist.strftime('%d/%m/%Y')}\n"
            f"üïê Turno: {checklist.get_turno_display()}\n"
            f"üìä Status: {status_emoji.get(checklist.status, '‚ùì')} {checklist.get_status_display()}\n\n"
            f"üîó Link web: {settings.BASE_URL}/api/nr12/checklist/{checklist.uuid}/\n\n"
            f"üí° Use o link acima para visualizar o checklist completo no navegador."
        )
        
    except Exception as e:
        logger.error(f"Erro ao processar checklist: {e}")
        await processing_msg.edit_text(
            "‚ùå Erro ao processar checklist.\n"
            "Por favor, tente novamente."
        )
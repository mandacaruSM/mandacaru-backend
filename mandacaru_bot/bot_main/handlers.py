# ===============================================
# ARQUIVO CORRIGIDO: mandacaru_bot/bot_main/handlers.py
# Handlers principais com fluxos completos
# ===============================================

import logging
import re
from datetime import datetime, date
from aiogram import Dispatcher, F
from aiogram.types import (
    Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton, 
    ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove
)
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from typing import Optional

# Imports do core
from core.config import API_BASE_URL, API_TIMEOUT
from core.session import (
    iniciar_sessao, obter_sessao, atualizar_sessao, 
    limpar_sessao, obter_operador_sessao, verificar_autenticacao,
    definir_equipamento_atual, obter_equipamento_atual,
    definir_dados_temporarios, obter_dados_temporarios
)
from core.db import (
    buscar_operador_por_nome, 
    buscar_operador_por_chat_id,
    buscar_equipamento_por_uuid,
    atualizar_chat_id_operador,
    registrar_abastecimento,
    criar_ordem_servico
)
from core.templates import MessageTemplates
from core.utils import Validators

logger = logging.getLogger(__name__)

# ===============================================
# DEFINI√á√ÉO DE ESTADOS FSM
# ===============================================

class AuthStates(StatesGroup):
    waiting_for_name = State()
    waiting_for_birth_date = State()

class EquipmentStates(StatesGroup):
    waiting_for_fuel_quantity = State()
    waiting_for_fuel_value = State()
    waiting_for_horimeter = State()
    waiting_for_os_description = State()

# ===============================================
# HANDLERS DE COMANDO PRINCIPAL
# ===============================================

async def start_handler(message: Message, state: FSMContext):
    """Handler principal do comando /start"""
    try:
        comando = message.text.strip()
        chat_id = str(message.chat.id)
        
        # Verificar se √© um QR code: /start eq_{uuid}
        match = re.match(r'/start eq_([a-f0-9\-]{36})', comando)
        
        if match:
            # Processar QR code de equipamento
            await handle_qr_code_start(message, state)
            return
        
        # Comando /start normal
        await process_normal_start(message, state)
        
    except Exception as e:
        logger.error(f"Erro no start_handler: {e}")
        await message.answer(
            "‚ùå Erro interno. Tente novamente em alguns instantes.",
            reply_markup=ReplyKeyboardRemove()
        )

async def process_normal_start(message: Message, state: FSMContext):
    """Processa /start normal (sem QR code)"""
    try:
        chat_id = str(message.chat.id)
        
        # Verificar se usu√°rio j√° est√° registrado
        operador_registrado = await buscar_operador_por_chat_id(chat_id)
        
        if operador_registrado:
            # Login autom√°tico
            await iniciar_sessao(chat_id, operador_registrado, 'AUTENTICADO')
            await show_main_menu(message, operador_registrado)
            return
        
        # N√£o registrado - iniciar processo de login
        await message.answer(
            MessageTemplates.welcome_template(),
            reply_markup=ReplyKeyboardRemove(),
            parse_mode="Markdown"
        )
        
        await message.answer(
            "üë§ **Informe seu nome completo:**",
            parse_mode="Markdown"
        )
        
        await state.set_state(AuthStates.waiting_for_name)
        
    except Exception as e:
        logger.error(f"Erro no process_normal_start: {e}")
        await message.answer("‚ùå Erro no processo de autentica√ß√£o.")

async def handle_qr_code_start(message: Message, state: FSMContext):
    """Handler para QR codes: /start eq_{uuid}"""
    try:
        comando = message.text.strip()
        chat_id = str(message.chat.id)
        
        # Extrair UUID do comando
        match = re.match(r'/start eq_([a-f0-9\-]{36})', comando)
        if not match:
            await process_normal_start(message, state)
            return
            
        uuid_equipamento = match.group(1)
        
        # Buscar equipamento na API
        equipamento_data = await buscar_equipamento_por_uuid(uuid_equipamento)
        
        if not equipamento_data:
            await message.answer(
                "‚ùå **Equipamento N√£o Encontrado**\n\n"
                "O QR Code escaneado n√£o corresponde a nenhum equipamento v√°lido.",
                parse_mode='Markdown'
            )
            return
        
        # Verificar se usu√°rio est√° autenticado
        operador = await obter_operador_sessao(chat_id)
        
        if operador:
            # Usu√°rio j√° logado - ir direto para menu do equipamento
            await definir_equipamento_atual(chat_id, equipamento_data)
            await mostrar_menu_equipamento(message, equipamento_data, operador)
            return
        
        # Verificar se chat_id est√° registrado no banco
        operador_banco = await buscar_operador_por_chat_id(chat_id)
        
        if operador_banco:
            # LOGIN AUTOM√ÅTICO para QR code
            await iniciar_sessao(chat_id, operador_banco, 'AUTENTICADO')
            await definir_equipamento_atual(chat_id, equipamento_data)
            
            await message.answer(
                f"üëã **Bem-vindo de volta, {operador_banco.get('nome')}!**\n\n"
                f"üöú Acessando equipamento **{equipamento_data.get('nome')}**...",
                parse_mode='Markdown'
            )
            
            await mostrar_menu_equipamento(message, equipamento_data, operador_banco)
            return
        
        # N√£o registrado - pedir login mas guardar contexto do equipamento
        await definir_dados_temporarios(chat_id, 'equipamento_qr_uuid', uuid_equipamento)
        await definir_dados_temporarios(chat_id, 'equipamento_qr_data', equipamento_data)
        
        await message.answer(
            f"üì± **QR Code: {equipamento_data.get('nome', 'Equipamento')}**\n\n"
            "üîê Para acessar este equipamento, primeiro fa√ßa seu login.\n\n"
            "üë§ **Informe seu nome completo:**",
            parse_mode='Markdown'
        )
        
        await state.set_state(AuthStates.waiting_for_name)
        
    except Exception as e:
        logger.error(f"Erro no QR Code: {e}")
        await message.answer(
            f"‚ùå **Erro no QR Code**\n\n"
            f"Ocorreu um erro: {str(e)}",
            parse_mode='Markdown'
        )

# ===============================================
# HANDLERS DE AUTENTICA√á√ÉO
# ===============================================

async def process_name(message: Message, state: FSMContext):
    """Processa nome informado pelo usu√°rio"""
    try:
        nome = message.text.strip()
        chat_id = str(message.chat.id)
        
        if not Validators.validar_nome(nome):
            await message.answer(
                "‚ùå Nome inv√°lido. Informe seu nome completo (m√≠nimo 3 caracteres):"
            )
            return
        
        # Buscar operadores com esse nome
        operadores = await buscar_operador_por_nome(nome)
        
        if not operadores:
            await message.answer(
                f"‚ùå **Operador n√£o encontrado**\n\n"
                f"N√£o foi encontrado nenhum operador com o nome '{nome}'.\n\n"
                f"Verifique se o nome est√° correto ou entre em contato com o administrador."
            )
            await state.clear()
            return
        
        if len(operadores) == 1:
            # Apenas um operador encontrado
            operador = operadores[0]
            await definir_dados_temporarios(chat_id, 'operador_candidato', operador)
            
            await message.answer(
                f"üë§ **Operador encontrado:**\n"
                f"üìã Nome: {operador.get('nome')}\n"
                f"üíº Fun√ß√£o: {operador.get('funcao', 'N/A')}\n\n"
                f"üìÖ **Informe sua data de nascimento** (DD/MM/AAAA):",
                parse_mode='Markdown'
            )
            
            await state.set_state(AuthStates.waiting_for_birth_date)
        else:
            # M√∫ltiplos operadores - mostrar lista para sele√ß√£o
            keyboard = []
            for operador in operadores[:5]:  # M√°ximo 5 op√ß√µes
                keyboard.append([
                    InlineKeyboardButton(
                        text=f"{operador.get('nome')} - {operador.get('funcao', 'N/A')}",
                        callback_data=f"select_operator_{operador.get('id')}"
                    )
                ])
            
            markup = InlineKeyboardMarkup(inline_keyboard=keyboard)
            
            await message.answer(
                f"üë• **M√∫ltiplos operadores encontrados**\n\n"
                f"Selecione seu perfil:",
                reply_markup=markup,
                parse_mode='Markdown'
            )
            
            # Guardar lista de operadores
            await definir_dados_temporarios(chat_id, 'operadores_candidatos', operadores)
        
    except Exception as e:
        logger.error(f"Erro ao processar nome: {e}")
        await message.answer("‚ùå Erro interno. Tente novamente.")

async def process_birth_date(message: Message, state: FSMContext):
    """Processa data de nascimento para autentica√ß√£o"""
    try:
        data_texto = message.text.strip()
        chat_id = str(message.chat.id)
        
        # Validar formato da data
        data_nascimento = Validators.validar_data_nascimento(data_texto)
        if not data_nascimento:
            await message.answer(
                "‚ùå Data inv√°lida. Use o formato DD/MM/AAAA (ex: 15/03/1990):"
            )
            return
        
        # Buscar operador candidato
        operador = await obter_dados_temporarios(chat_id, 'operador_candidato')
        if not operador:
            await message.answer("‚ùå Erro na sess√£o. Digite /start para recome√ßar.")
            await state.clear()
            return
        
        # Verificar data de nascimento
        data_banco_str = operador.get('data_nascimento')
        if not data_banco_str:
            await message.answer(
                "‚ùå **Data de nascimento n√£o cadastrada**\n\n"
                "Entre em contato com o administrador para regularizar seu cadastro."
            )
            await state.clear()
            return
        
        # Comparar datas
        try:
            data_banco = datetime.strptime(data_banco_str, '%Y-%m-%d').date()
        except:
            data_banco = datetime.strptime(data_banco_str, '%d/%m/%Y').date()
        
        if data_nascimento != data_banco:
            await message.answer(
                "‚ùå **Data de nascimento incorreta**\n\n"
                "A data informada n√£o confere com nossos registros."
            )
            await state.clear()
            return
        
        # Autentica√ß√£o bem-sucedida
        await complete_authentication(message, state, operador)
        
    except Exception as e:
        logger.error(f"Erro ao processar data de nascimento: {e}")
        await message.answer("‚ùå Erro na autentica√ß√£o. Tente novamente.")

async def complete_authentication(message: Message, state: FSMContext, operador: dict):
    """Completa o processo de autentica√ß√£o"""
    try:
        chat_id = str(message.chat.id)
        
        # Atualizar chat_id no banco de dados
        operador_id = operador.get('id')
        await atualizar_chat_id_operador(operador_id, chat_id)
        
        # Iniciar sess√£o
        await iniciar_sessao(chat_id, operador, 'AUTENTICADO')
        
        # Verificar se veio de QR code
        equipamento_qr = await obter_dados_temporarios(chat_id, 'equipamento_qr_data')
        
        if equipamento_qr:
            # Definir equipamento atual e ir para menu espec√≠fico
            await definir_equipamento_atual(chat_id, equipamento_qr)
            
            await message.answer(
                f"‚úÖ **Login realizado com sucesso!**\n\n"
                f"üëã Bem-vindo, {operador['nome']}!\n\n"
                f"üöú Acessando equipamento **{equipamento_qr.get('nome')}**...",
                parse_mode='Markdown'
            )
            await mostrar_menu_equipamento(message, equipamento_qr, operador)
        else:
            # Mostrar menu principal
            await show_main_menu(message, operador)
        
        await state.clear()
        
    except Exception as e:
        logger.error(f"Erro no processo de autentica√ß√£o: {e}")
        await message.answer(
            "‚ùå Erro na autentica√ß√£o. N√£o foi poss√≠vel completar o login."
        )
        await state.clear()

# ===============================================
# HANDLERS DE CALLBACK
# ===============================================

async def handle_operator_selection(callback: CallbackQuery, state: FSMContext):
    """Handler para sele√ß√£o de operador quando h√° m√∫ltiplos"""
    try:
        data = callback.data
        chat_id = str(callback.from_user.id)
        
        # Extrair ID do operador
        match = re.match(r'select_operator_(\d+)', data)
        if not match:
            await callback.answer("‚ùå Erro na sele√ß√£o")
            return
        
        operador_id = int(match.group(1))
        
        # Buscar operador na lista de candidatos
        operadores_candidatos = await obter_dados_temporarios(chat_id, 'operadores_candidatos', [])
        operador = next((op for op in operadores_candidatos if op.get('id') == operador_id), None)
        
        if not operador:
            await callback.answer("‚ùå Operador n√£o encontrado")
            return
        
        await callback.answer()
        await definir_dados_temporarios(chat_id, 'operador_candidato', operador)
        
        await callback.message.answer(
            f"üë§ **Operador selecionado:**\n"
            f"üìã Nome: {operador.get('nome')}\n"
            f"üíº Fun√ß√£o: {operador.get('funcao', 'N/A')}\n\n"
            f"üìÖ **Informe sua data de nascimento** (DD/MM/AAAA):",
            parse_mode='Markdown'
        )
        
        await state.set_state(AuthStates.waiting_for_birth_date)
        
    except Exception as e:
        logger.error(f"Erro na sele√ß√£o de operador: {e}")
        await callback.answer("‚ùå Erro interno")

async def handle_menu_callback(callback: CallbackQuery):
    """Handler para callbacks do menu principal"""
    try:
        data = callback.data
        chat_id = str(callback.from_user.id)
        
        # Verificar autentica√ß√£o
        operador = await obter_operador_sessao(chat_id)
        if not operador:
            await callback.answer("‚ùå Sess√£o expirada. Digite /start")
            return
        
        await callback.answer()
        
        if data == "menu_checklist":
            await show_checklist_menu(callback.message, operador)
            
        elif data == "menu_abastecimento":
            await show_abastecimento_menu(callback.message, operador)
            
        elif data == "menu_os":
            await show_os_menu(callback.message, operador)
            
        elif data == "menu_financeiro":
            await show_financeiro_menu(callback.message, operador)
            
        elif data == "menu_qrcode":
            await show_qrcode_menu(callback.message, operador)
            
        elif data == "menu_principal":
            await show_main_menu(callback.message, operador)
            
        elif data == "menu_ajuda":
            await show_help_menu(callback.message)
            
        else:
            await callback.message.answer(
                f"üöß **{data.replace('menu_', '').title()}**\n\n"
                "Este m√≥dulo est√° em desenvolvimento.\n"
                "Em breve estar√° dispon√≠vel!",
                parse_mode='Markdown'
            )
            
    except Exception as e:
        logger.error(f"Erro no callback de menu: {e}")
        await callback.answer("‚ùå Erro interno")

async def handle_equipamento_callback(callback: CallbackQuery, state: FSMContext):
    """Handler para callbacks de a√ß√µes do equipamento"""
    try:
        data = callback.data
        chat_id = str(callback.from_user.id)
        
        # Verificar autentica√ß√£o
        operador = await obter_operador_sessao(chat_id)
        if not operador:
            await callback.answer("‚ùå Sess√£o expirada")
            return
        
        await callback.answer()
        
        # Extrair ID do equipamento e a√ß√£o
        if data.startswith("eq_"):
            parts = data.split("_", 2)
            if len(parts) >= 3:
                acao = parts[1]
                equipamento_id = parts[2]
            else:
                await callback.message.answer("‚ùå Comando inv√°lido")
                return
            
            if acao == "novo" and "checklist" in data:
                # Novo checklist
                await iniciar_novo_checklist(callback.message, equipamento_id, operador)
                
            elif acao == "abastecimento":
                # Registrar abastecimento
                await iniciar_abastecimento(callback.message, state, equipamento_id, operador)
                
            elif acao == "os":
                # Abrir OS
                await iniciar_ordem_servico(callback.message, state, equipamento_id, operador)
                
            elif acao == "horimetro":
                # Atualizar hor√≠metro
                await iniciar_atualizacao_horimetro(callback.message, state, equipamento_id, operador)
                
            elif acao == "historico":
                # Ver hist√≥rico
                await mostrar_historico_equipamento(callback.message, equipamento_id, operador)
        
        elif data.startswith("cancelar_"):
            # Cancelar opera√ß√£o
            await callback.message.answer("‚ùå Opera√ß√£o cancelada.")
            await state.clear()
            
    except Exception as e:
        logger.error(f"Erro no callback de equipamento: {e}")
        await callback.answer("‚ùå Erro interno")

# ===============================================
# MENUS E NAVEGA√á√ÉO
# ===============================================

def criar_menu_principal():
    """Cria o menu principal do bot"""
    keyboard = [
        [InlineKeyboardButton(text="üìã Checklist", callback_data="menu_checklist")],
        [InlineKeyboardButton(text="‚õΩ Abastecimento", callback_data="menu_abastecimento")],
        [InlineKeyboardButton(text="üîß Ordem de Servi√ßo", callback_data="menu_os")],
        [InlineKeyboardButton(text="üí∞ Financeiro", callback_data="menu_financeiro")],
        [InlineKeyboardButton(text="üì± QR Code", callback_data="menu_qrcode")],
        [InlineKeyboardButton(text="‚ùì Ajuda", callback_data="menu_ajuda")]
    ]
    return InlineKeyboardMarkup(inline_keyboard=keyboard)

async def show_main_menu(message: Message, operador: dict):
    """Mostra o menu principal ap√≥s autentica√ß√£o"""
    keyboard = criar_menu_principal()
    
    is_admin = operador.get('is_admin', False)
    admin_text = "\n\nüîë *Voc√™ tem privil√©gios de administrador!*\nUse /admin para acessar o painel." if is_admin else ""
    
    await message.answer(
        f"‚úÖ **Login realizado com sucesso!**\n\n"
        f"üë§ Operador: {operador['nome']}\n"
        f"üíº Fun√ß√£o: {operador.get('funcao', 'Operador')}\n"
        f"üïê Hor√°rio: {datetime.now().strftime('%d/%m/%Y %H:%M')}"
        f"{admin_text}\n\n"
        f"Escolha uma op√ß√£o abaixo:",
        reply_markup=keyboard,
        parse_mode="Markdown"
    )

async def mostrar_menu_equipamento(message: Message, equipamento_data: dict, operador: dict):
    """Mostra menu de a√ß√µes para o equipamento"""
    try:
        equipamento_id = equipamento_data.get('id')
        nome = equipamento_data.get('nome', 'Equipamento')
        horimetro = equipamento_data.get('horimetro_atual', 0)
        status = equipamento_data.get('status_operacional', 'Desconhecido')
        
        # Criar menu
        keyboard = [
            [InlineKeyboardButton(text="üìã Novo Checklist NR12", callback_data=f"eq_novo_checklist_{equipamento_id}")],
            [InlineKeyboardButton(text="‚õΩ Registrar Abastecimento", callback_data=f"eq_abastecimento_{equipamento_id}")],
            [InlineKeyboardButton(text="üîß Abrir Ordem de Servi√ßo", callback_data=f"eq_os_{equipamento_id}")],
            [InlineKeyboardButton(text="‚è±Ô∏è Atualizar Hor√≠metro", callback_data=f"eq_horimetro_{equipamento_id}")],
            [InlineKeyboardButton(text="üìä Ver Hist√≥rico", callback_data=f"eq_historico_{equipamento_id}")],
            [InlineKeyboardButton(text="üè† Menu Principal", callback_data="menu_principal")]
        ]
        
        markup = InlineKeyboardMarkup(inline_keyboard=keyboard)
        
        mensagem = f"""üöú **{nome}**

üìä **Status:** {status}
‚è±Ô∏è **Hor√≠metro:** {horimetro:,.0f}h
üë§ **Operador:** {operador.get('nome', 'N/A')}

üéØ **O que voc√™ deseja fazer?**"""
        
        await message.answer(
            mensagem,
            reply_markup=markup,
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Erro ao mostrar menu do equipamento: {e}")
        await message.answer("‚ùå Erro ao carregar dados do equipamento")

# ===============================================
# MENUS ESPEC√çFICOS DOS M√ìDULOS
# ===============================================

async def show_checklist_menu(message: Message, operador: dict):
    """Mostra menu do m√≥dulo checklist"""
    keyboard = [
        [InlineKeyboardButton(text="üìã Meus Checklists", callback_data="checklist_meus")],
        [InlineKeyboardButton(text="üîó Acessar Equipamentos", callback_data="checklist_links")],
        [InlineKeyboardButton(text="‚ùì Como Usar", callback_data="checklist_ajuda")],
        [InlineKeyboardButton(text="üè† Menu Principal", callback_data="menu_principal")]
    ]
    
    markup = InlineKeyboardMarkup(inline_keyboard=keyboard)
    
    await message.answer(
        "üìã **M√≥dulo Checklist**\n\n"
        "üéØ **Op√ß√µes dispon√≠veis:**\n"
        "‚Ä¢ Ver seus checklists\n"
        "‚Ä¢ Acessar equipamentos\n"
        "‚Ä¢ Aprender a usar\n\n"
        "Escolha uma op√ß√£o:",
        reply_markup=markup,
        parse_mode='Markdown'
    )

async def show_abastecimento_menu(message: Message, operador: dict):
    """Mostra menu do m√≥dulo abastecimento"""
    await message.answer(
        "‚õΩ **M√≥dulo Abastecimento**\n\n"
        "üöß Este m√≥dulo est√° em desenvolvimento.\n"
        "Em breve voc√™ poder√°:\n\n"
        "‚Ä¢ Registrar abastecimentos\n"
        "‚Ä¢ Ver hist√≥rico de combust√≠vel\n"
        "‚Ä¢ Controlar consumo\n\n"
        "Para registrar um abastecimento, escaneie o QR code do equipamento.",
        parse_mode='Markdown'
    )

async def show_os_menu(message: Message, operador: dict):
    """Mostra menu do m√≥dulo OS"""
    await message.answer(
        "üîß **M√≥dulo Ordem de Servi√ßo**\n\n"
        "üöß Este m√≥dulo est√° em desenvolvimento.\n"
        "Em breve voc√™ poder√°:\n\n"
        "‚Ä¢ Abrir ordens de servi√ßo\n"
        "‚Ä¢ Acompanhar status\n"
        "‚Ä¢ Ver hist√≥rico de manuten√ß√µes\n\n"
        "Para abrir uma OS, escaneie o QR code do equipamento.",
        parse_mode='Markdown'
    )

async def show_financeiro_menu(message: Message, operador: dict):
    """Mostra menu do m√≥dulo financeiro"""
    await message.answer(
        "üí∞ **M√≥dulo Financeiro**\n\n"
        "üöß Este m√≥dulo est√° em desenvolvimento.\n"
        "Em breve voc√™ poder√°:\n\n"
        "‚Ä¢ Ver relat√≥rios de custos\n"
        "‚Ä¢ Acompanhar or√ßamentos\n"
        "‚Ä¢ Controlar despesas\n\n"
        "Aguarde as pr√≥ximas vers√µes!",
        parse_mode='Markdown'
    )

async def show_qrcode_menu(message: Message, operador: dict):
    """Mostra menu do m√≥dulo QR Code"""
    await message.answer(
        "üì± **M√≥dulo QR Code**\n\n"
        "üéØ **Como usar:**\n"
        "1. Aponte a c√¢mera para o QR code do equipamento\n"
        "2. Toque no link que aparecer\n"
        "3. Acesse diretamente as fun√ß√µes do equipamento\n\n"
        "üìã **Funcionalidades via QR:**\n"
        "‚Ä¢ Checklist NR12\n"
        "‚Ä¢ Registro de abastecimento\n"
        "‚Ä¢ Abertura de OS\n"
        "‚Ä¢ Atualiza√ß√£o de hor√≠metro\n\n"
        "‚úÖ Os QR codes est√£o dispon√≠veis em cada equipamento.",
        parse_mode='Markdown'
    )

async def show_help_menu(message: Message):
    """Mostra menu de ajuda"""
    await message.answer(
        "‚ùì **Central de Ajuda**\n\n"
        "ü§ñ **Como usar o bot:**\n"
        "1. Fa√ßa login com /start\n"
        "2. Use os bot√µes do menu\n"
        "3. Escaneie QR codes dos equipamentos\n\n"
        "üì± **Comandos dispon√≠veis:**\n"
        "‚Ä¢ /start - Fazer login\n"
        "‚Ä¢ /admin - Painel administrativo (admins)\n\n"
        "üÜò **Precisa de ajuda?**\n"
        "Entre em contato com o suporte t√©cnico.\n\n"
        "üìû Suporte: (11) 99999-9999",
        parse_mode='Markdown'
    )

# ===============================================
# HANDLERS DE EQUIPAMENTO (FSM)
# ===============================================

async def iniciar_abastecimento(message: Message, state: FSMContext, equipamento_id: str, operador: dict):
    """Inicia o processo de registro de abastecimento"""
    try:
        await definir_dados_temporarios(str(message.chat.id), 'equipamento_id_ativo', equipamento_id)
        
        await message.answer(
            "‚õΩ **Registrar Abastecimento**\n\n"
            "üìä Informe a quantidade abastecida em litros:\n"
            "*(ex: 45.5)*",
            parse_mode='Markdown'
        )
        
        await state.set_state(EquipmentStates.waiting_for_fuel_quantity)
        
    except Exception as e:
        logger.error(f"Erro ao iniciar abastecimento: {e}")
        await message.answer("‚ùå Erro ao iniciar registro de abastecimento")

async def process_fuel_quantity(message: Message, state: FSMContext):
    """Processa quantidade de combust√≠vel"""
    try:
        chat_id = str(message.chat.id)
        
        try:
            quantidade = float(message.text.replace(',', '.'))
            if quantidade <= 0:
                raise ValueError("Quantidade deve ser positiva")
        except ValueError:
            await message.answer("‚ùå Valor inv√°lido. Digite apenas n√∫meros (ex: 45.5):")
            return
        
        await definir_dados_temporarios(chat_id, 'abastecimento_quantidade', quantidade)
        
        await message.answer(
            f"‚õΩ **Quantidade:** {quantidade:.1f} litros\n\n"
            f"üí∞ Agora informe o valor total pago:\n"
            f"*(ex: 250.75)*",
            parse_mode='Markdown'
        )
        
        await state.set_state(EquipmentStates.waiting_for_fuel_value)
        
    except Exception as e:
        logger.error(f"Erro ao processar quantidade: {e}")
        await message.answer("‚ùå Erro interno. Tente novamente.")

async def process_fuel_value(message: Message, state: FSMContext):
    """Processa valor do abastecimento"""
    try:
        chat_id = str(message.chat.id)
        
        try:
            valor = float(message.text.replace(',', '.'))
            if valor <= 0:
                raise ValueError("Valor deve ser positivo")
        except ValueError:
            await message.answer("‚ùå Valor inv√°lido. Digite apenas n√∫meros (ex: 250.75):")
            return
        
        # Buscar dados salvos
        quantidade = await obter_dados_temporarios(chat_id, 'abastecimento_quantidade')
        equipamento_id = await obter_dados_temporarios(chat_id, 'equipamento_id_ativo')
        operador = await obter_operador_sessao(chat_id)
        
        if not all([quantidade, equipamento_id, operador]):
            await message.answer("‚ùå Erro na sess√£o. Tente novamente.")
            await state.clear()
            return
        
        # Registrar abastecimento
        resultado = await registrar_abastecimento(
            equipamento_id=int(equipamento_id),
            operador_id=operador.get('id'),
            quantidade_litros=quantidade,
            valor_total=valor
        )
        
        if resultado:
            preco_litro = valor / quantidade
            
            await message.answer(
                f"‚úÖ **Abastecimento Registrado!**\n\n"
                f"‚õΩ Quantidade: {quantidade:.1f} litros\n"
                f"üí∞ Valor: R$ {valor:.2f}\n"
                f"üí≤ Pre√ßo/litro: R$ {preco_litro:.3f}\n"
                f"üìÖ Data: {datetime.now().strftime('%d/%m/%Y %H:%M')}\n\n"
                f"Registro salvo com sucesso!",
                parse_mode='Markdown',
                reply_markup=ReplyKeyboardRemove()
            )
        else:
            await message.answer(
                "‚ùå **Erro ao registrar abastecimento**\n\n"
                "N√£o foi poss√≠vel salvar os dados. Tente novamente.",
                reply_markup=ReplyKeyboardRemove()
            )
        
        await state.clear()
        
    except Exception as e:
        logger.error(f"Erro ao processar valor: {e}")
        await message.answer("‚ùå Erro interno. Tente novamente.")

async def iniciar_ordem_servico(message: Message, state: FSMContext, equipamento_id: str, operador: dict):
    """Inicia processo de abertura de OS"""
    try:
        await definir_dados_temporarios(str(message.chat.id), 'equipamento_id_ativo', equipamento_id)
        
        # Criar teclado com tipos de problema
        keyboard = [
            [InlineKeyboardButton(text="üîß Manuten√ß√£o Preventiva", callback_data="os_tipo_PREVENTIVA")],
            [InlineKeyboardButton(text="‚ö†Ô∏è Manuten√ß√£o Corretiva", callback_data="os_tipo_CORRETIVA")],
            [InlineKeyboardButton(text="‚ö° Problema El√©trico", callback_data="os_tipo_ELETRICO")],
            [InlineKeyboardButton(text="üî© Problema Mec√¢nico", callback_data="os_tipo_MECANICO")],
            [InlineKeyboardButton(text="üõ†Ô∏è Outros", callback_data="os_tipo_OUTROS")],
            [InlineKeyboardButton(text="‚ùå Cancelar", callback_data="cancelar_os")]
        ]
        
        markup = InlineKeyboardMarkup(inline_keyboard=keyboard)
        
        await message.answer(
            "üîß **Abrir Ordem de Servi√ßo**\n\n"
            "Selecione o tipo de problema:",
            reply_markup=markup,
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Erro ao iniciar OS: {e}")
        await message.answer("‚ùå Erro ao iniciar abertura de OS")

async def handle_os_type_callback(callback: CallbackQuery, state: FSMContext):
    """Handler para tipo de OS selecionado"""
    try:
        data = callback.data
        chat_id = str(callback.from_user.id)
        
        operador = await obter_operador_sessao(chat_id)
        if not operador:
            await callback.answer("‚ùå Sess√£o expirada")
            return
        
        await callback.answer()
        
        if data == "cancelar_os":
            await callback.message.answer("‚ùå Cria√ß√£o de OS cancelada.")
            await state.clear()
            return
        
        # Extrair tipo
        tipo = data.replace("os_tipo_", "")
        await definir_dados_temporarios(chat_id, 'os_tipo', tipo)
        
        tipos_dict = {
            'PREVENTIVA': 'Manuten√ß√£o Preventiva',
            'CORRETIVA': 'Manuten√ß√£o Corretiva',
            'ELETRICO': 'Problema El√©trico',
            'MECANICO': 'Problema Mec√¢nico',
            'OUTROS': 'Outros'
        }
        
        await callback.message.answer(
            f"üîß **Tipo:** {tipos_dict.get(tipo, tipo)}\n\n"
            f"üìù Agora descreva o problema detalhadamente:",
            parse_mode='Markdown'
        )
        
        await state.set_state(EquipmentStates.waiting_for_os_description)
        
    except Exception as e:
        logger.error(f"Erro no callback de tipo OS: {e}")
        await callback.answer("‚ùå Erro interno")

async def process_os_description(message: Message, state: FSMContext):
    """Processa descri√ß√£o da OS"""
    try:
        chat_id = str(message.chat.id)
        descricao = message.text.strip()
        
        if len(descricao) < 10:
            await message.answer("‚ùå Descri√ß√£o muito curta. Detalhe melhor o problema:")
            return
        
        # Buscar dados salvos
        equipamento_id = await obter_dados_temporarios(chat_id, 'equipamento_id_ativo')
        tipo = await obter_dados_temporarios(chat_id, 'os_tipo')
        operador = await obter_operador_sessao(chat_id)
        
        if not all([equipamento_id, tipo, operador]):
            await message.answer("‚ùå Erro na sess√£o. Tente novamente.")
            await state.clear()
            return
        
        # Criar OS
        resultado = await criar_ordem_servico(
            equipamento_id=int(equipamento_id),
            operador_id=operador.get('id'),
            descricao=descricao,
            tipo_problema=tipo
        )
        
        if resultado:
            await message.answer(
                f"‚úÖ **Ordem de Servi√ßo Criada!**\n\n"
                f"üîß Tipo: {tipo}\n"
                f"üÜî N√∫mero: {resultado.get('id')}\n"
                f"üìù Descri√ß√£o: {descricao}\n"
                f"üìÖ Abertura: {datetime.now().strftime('%d/%m/%Y %H:%M')}\n\n"
                f"A equipe de manuten√ß√£o foi notificada!",
                parse_mode='Markdown'
            )
        else:
            await message.answer(
                "‚ùå **Erro ao criar OS**\n\n"
                "N√£o foi poss√≠vel criar a ordem de servi√ßo. Tente novamente."
            )
        
        await state.clear()
        
    except Exception as e:
        logger.error(f"Erro ao processar descri√ß√£o da OS: {e}")
        await message.answer("‚ùå Erro interno. Tente novamente.")

# ===============================================
# OUTRAS FUN√á√ïES AUXILIARES
# ===============================================

async def iniciar_novo_checklist(message: Message, equipamento_id: str, operador: dict):
    """Placeholder para iniciar novo checklist"""
    await message.answer(
        "üìã **Novo Checklist**\n\n"
        "üöß Esta funcionalidade ser√° implementada em breve!\n"
        "Aguarde as pr√≥ximas atualiza√ß√µes.",
        parse_mode='Markdown'
    )

async def iniciar_atualizacao_horimetro(message: Message, state: FSMContext, equipamento_id: str, operador: dict):
    """Placeholder para atualizar hor√≠metro"""
    await message.answer(
        "‚è±Ô∏è **Atualizar Hor√≠metro**\n\n"
        "üöß Esta funcionalidade ser√° implementada em breve!\n"
        "Aguarde as pr√≥ximas atualiza√ß√µes.",
        parse_mode='Markdown'
    )

async def mostrar_historico_equipamento(message: Message, equipamento_id: str, operador: dict):
    """Placeholder para mostrar hist√≥rico"""
    await message.answer(
        "üìä **Hist√≥rico do Equipamento**\n\n"
        "üöß Esta funcionalidade ser√° implementada em breve!\n"
        "Aguarde as pr√≥ximas atualiza√ß√µes.",
        parse_mode='Markdown'
    )

# ===============================================
# REGISTRO DOS HANDLERS
# ===============================================

def register_handlers(dp: Dispatcher):
    """Registra todos os handlers principais"""
    
    # Comandos
    dp.message.register(start_handler, Command("start"))
    
    # Estados de autentica√ß√£o
    dp.message.register(process_name, AuthStates.waiting_for_name)
    dp.message.register(process_birth_date, AuthStates.waiting_for_birth_date)
    
    # Estados de equipamento
    dp.message.register(process_fuel_quantity, EquipmentStates.waiting_for_fuel_quantity)
    dp.message.register(process_fuel_value, EquipmentStates.waiting_for_fuel_value)
    dp.message.register(process_os_description, EquipmentStates.waiting_for_os_description)
    
    # Callbacks principais
    dp.callback_query.register(handle_operator_selection, F.data.startswith("select_operator_"))
    dp.callback_query.register(handle_menu_callback, F.data.startswith("menu_"))
    dp.callback_query.register(handle_equipamento_callback, F.data.startswith("eq_"))
    dp.callback_query.register(handle_os_type_callback, F.data.startswith("os_tipo_"))
    
    logger.info("Handlers principais registrados com sucesso")